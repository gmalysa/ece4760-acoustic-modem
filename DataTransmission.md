# Introduction #

Our basic encoding scheme is a variant on what is known as [On-Off Keying](http://en.wikipedia.org/wiki/On-off_keying), where a single frequency's presence or absence is used to encode a zero or a one bit. In a manner similar to the RS-232 serial protocol, we transmit data in 10-bit frames, consisting of one start bit, 8 bits of data, and one stop bit. The start bit is always a 1, and is used to capture the beginning of the frame more precisely, while the stop bit is a zero to ensure that there will be another low-to-high transition in order to re-lock the tracking and prevent errors in the allocation of bit windows from accumulating across several bytes.

In addition, we intend on using multiple frequencies in parallel to transmit a higher volume of data using the same modulation scheme for each frequency. The bandwidth is limited by a number of factors including the processing power of our target platform, the Atmega 644, and the sound producing capabilities of the speakers and microphones we are using: 100 Hz - 20 kHz. In order to meet the Nyquist rate for these speakers and microphones, we are sampling at 40 kHz, which leaves 500 cycles (with a 20 MHz crystal oscillator) for computation per sample, which must include both synthesis and decoding for all frequencies. The Atmega 644 is an 8-bit RISC microcontroller with hardware support for multiplication but no native floating point capabilities.

# Frequency Selection and Pulse Design #
With the use of on-off keying, a particular frequency may represent one serial stream of data, if its presence or absence is recorded over time. Therefore, multiple frequencies will increase the bandwidth of the channel. However, the system must be able to determine which frequencies are present, which requires that each burst be long enough for some type of spectrum analysis to discriminate (about 4-5 cycles if the frequencies are sufficiently spaced), which places a lower limit on the pulse duration and an upper limit on the bandwidth per channel.

Because of the Atmega644's limited computational power, doing FFTs or running DTFTs on the frequencies of interest is not the most effective way to process the incoming sound data. Instead, the incoming data is resampled at the frequency of interest, relying on aliasing to cause the frequency of interest to appear as a DC component. However, although it is aliasing down to DC, it is possible that it still has a phase component that prevents it from appearing as DC when sampled at evenly spaced intervals, so the incoming wave must be resampled twice with a 90 degree phase difference between the two in order to ensure that some amplitude is seen at DC. A moving average filter (which can be implemented efficiently as an FIR filter that cheats by storing previous computations and a ring buffer of previous values to subtract as they are no longer set to be included) can be used for detection--The magnitude squared filter's output for both a "cosine" and "sine" term (for the in-phase and +90 degree resamplers, respectively) as a complex number is equal to the DC component of the Fourier Transform of the signal.

When using multiple frequencies, this purposeful use of aliasing requires that none of the frequencies alias to one another--they are all therefore not related to one another by integer multiples. For that purpose we have chosen eight possible frequencies for use: 4, 6, 7, 9, 10, 11, 13, and 15 kHz. The frequencies are allowed to share a factor (such as 2 kHz or 1 kHz) because resampling will not happen at those frequencies. The minimum frequency here has a period of 0.25ms; taking the length of a 5-cycle burst in sample periods and rounding up to 64 samples (a power of 2, and thus convenient for circular buffers) results in a burst length of 1.6 ms. Because ten bits are used to encode each byte (1 start bit, 8 data bits, and 1 stop bit), the effective maximum throughput is 62.5 bytes/second/frequency.

Finally, in order to reduce spectral leakage, a window function is applied to the bursts. For this purpose, a Hann window of length 64 was chosen to match the length of each burst exactly. This window is pre-applied in the matlab generation code to all of the precomputed sample data.

# Waveform Generation on the Atmega644 #
Generating a waveform of any quality is normally a very time-consuming task. With a target sampling frequency of 40 kHz, there are approximately 500 cycles available per sample, which must handle all synthesis, signal processing, and serial communications. Serial communications will be infrequent compared to the sampling rate, luckily, so they can largely be ignored, leaving on average the full 500 cycles for synthesis and signal processing.

Because all of the frequencies that must be synthesized are known beforehand, and each pulse has a particular shape and precise duration, it is easiest to simply store all possible waveforms in flash memory. The Atmega644 has 64 KB of flash memory for program and non-volatile data--of this, we use approximately 32 KB to store pre-computed burst patterns corresponding to all possible combinations of frequency.

When a byte is received over serial, it is added to the output buffer on the next available frequency channel. Then, as bit boundaries are reached in the transmit routine, a new set of 64 samples is selected from flash memory based on which bits need to be transmitted and copied into RAM (which has a lower access latency, to speed things up a bit later...this may actually be a waste of time).

For each sample that is synthesized, Digital-to-Analog conversion is handled by an AD7801 parallel 8-bit DAC. This chip is connected to all of PORTC, which is driven in one cycle with the sample value read from flash memory. The appropriate bits are strobed on the DAC to load the new sample into its output and D/A conversion is complete. 8-bits of output plus a little bit of filtering in hardware has proven to produce a sufficiently recognizable waveform for our purposes. This synthesis method was chosen to be as simple as possible and hopefully have as low an overhead as possible in order to reserve more cycles for the signal processing algorithms, while still providing some quality (arguably more than DDS through PWM).

# Duplex and Multicast Communications #
Not currently supported.